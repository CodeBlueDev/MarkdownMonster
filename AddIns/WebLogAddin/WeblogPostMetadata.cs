using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Policy;
using System.Text;
using System.Xml;
using MarkdownMonster;
using WebLogAddin.MetaWebLogApi;
using Westwind.Utilities;
using YamlDotNet.RepresentationModel;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;


namespace WeblogAddin
{
    public class WeblogPostMetadata : INotifyPropertyChanged
    {


	    /// <summary>
	    /// The title of the post derived from the document's header
	    /// </summary>
	    public string Title
	    {
		    get { return _title; }
		    set
		    {
			    if (value == _title) return;
			    _title = value;
			    OnPropertyChanged(nameof(Title));
		    }
	    }
	    private string _title;


		/// <summary>
		/// Url that is mapped to wp_thumbnail
		/// </summary>
		public string FeaturedImageUrl { get; set; }

        /// <summary>
        /// Featured Image Id used for Wordpress
        /// </summary>
        public string FeaturedImageId { get; set; }


        /// <summary>
        /// Short abstract text for the post.
        /// </summary>
        public string Abstract
        {
            get { return _abstract; }
            set
            {
                if (value == _abstract) return;
                _abstract = value;
                OnPropertyChanged(nameof(Abstract));
            }
        }
	    private string _abstract;




		/// <summary>
		/// Keywords that are added to the post when published.
		/// Typically these are added to the document meta data.
		/// </summary>
		public string Keywords { get; set; }

        /// <summary>
        /// Categories that this post is associated with
        /// </summary>
        public string Categories { get; set; }

        /// <summary>
        /// The Weblog that this post is to be sent to
        /// </summary>
        public string WeblogName { get; set; }

        /// <summary>
        /// The post id - empty on new entries, and set to
        /// the id generated on the server after a post
        /// was uploaded.
        /// </summary>
        public string PostId { get; set; }


        /// <summary>
        /// The post permalink as generated by the server.
        /// Can potentially be updated if the server supports it
        /// </summary>
        public string Permalink { get; set; }

        /// <summary>
        /// The date the post was made
        /// </summary>
        public DateTime PostDate { get; set; } = DateTime.Now;

        ///// <summary>
        ///// Determines whether a post is published or
        ///// a unpublished draft.
        ///// </summary>
        //public bool IsDraft
        //{
        //    get { return _isDraft; }
        //    set
        //    {
        //        if (value == _isDraft) return;
        //        _isDraft = value;
        //        OnPropertyChanged(nameof(IsDraft));
	       //     if (value)
		      //      PostStatus = "draft";
        //    }
        //}


		/// <summary>
		/// Post status for this post
		/// Supported values: publish, draft, private
		/// </summary>
		[DefaultValue("publish")]
	    public string PostStatus
	    {
		    get { return _postStatus; }
		    set
		    {
				if (value == _postStatus) return;
				_postStatus = value;
			    OnPropertyChanged();
		    }
	    }
	    private string _postStatus = "publish";

		/// <summary>
		/// Determines whether the addin tries to infer the featured
		/// image based on the first image in the post.
		///
		/// If false, only explicitly set images in the meta data
		/// are used.
		/// </summary>
		public bool DontInferFeaturedImage
        {
            get { return _dontInferFeaturedImage; }
            set
            {
                if (value == _dontInferFeaturedImage) return;
                _dontInferFeaturedImage = value;
                OnPropertyChanged(nameof(DontInferFeaturedImage));
            }
        }
        private bool _dontInferFeaturedImage = false;

        /// <summary>
        /// By default an H1 header at the top document is stripped
        /// </summary>
        public bool DontStripH1Header
        {
            get { return _dontStripH1Header; }
            set
            {
                if (value == _dontStripH1Header) return;
                _dontStripH1Header = value;
                OnPropertyChanged(nameof(DontStripH1Header));
            }
        }
        private bool _dontStripH1Header = false;

        /// <summary>
        /// A collection of custom fields that are uploaded to the server
        /// </summary>
        public IDictionary<string,CustomField> CustomFields { get; set;} = new Dictionary<string, CustomField>();


        [YamlIgnore]
        public IDictionary<string, object> ExtraValues { get; set; } = new Dictionary<string, object>();

		/// <summary>
		/// This should hold the sanitized markdown text
		/// stripped of the config data.
		/// </summary>
		[YamlIgnore]
        public string MarkdownBody { get; set; }

        /// <summary>
        /// Holds the Yaml Front Matter when parsing
        /// </summary>
        [YamlIgnore]
        public string YamlFrontMatter { get; set; }

        /// <summary>
        /// This should hold the raw markdown text retrieved
        /// from the editor which will contain the meta post data
        /// </summary>
        [YamlIgnore]
        public string RawMarkdownBody { get; set; }



        /// <summary>
        /// Strips the Markdown Meta data from the message and populates
        /// the post structure with the meta data values.
        /// </summary>
        /// <param name="markdown">The raw markdown document with YAML header (optional)</param>
        /// <param name="post">Optional empty <seealso cref="Post"/> object that is filled with the meta data in.</param>
        public static WeblogPostMetadata GetPostYamlConfigFromMarkdown(string markdown, Post post = null)
        {
            var meta = new WeblogPostMetadata()
            {
                RawMarkdownBody = markdown,
                MarkdownBody = markdown,
                WeblogName = WeblogAddinConfiguration.Current.LastWeblogAccessed,
                CustomFields = new Dictionary<string, CustomField>()
            };


            if (string.IsNullOrEmpty(markdown))
                return meta;

            markdown = markdown.Trim();

            if (!markdown.StartsWith("---\n") && !markdown.StartsWith("---\r"))
                return meta;

            

            // YAML with --- so we can replace
            string extractedYaml = MarkdownUtilities.ExtractFrontMatter(markdown,false);
            if (string.IsNullOrEmpty(extractedYaml))
                return meta;

            // just the YAML text
            var yaml = extractedYaml.Trim('-', ' ', '\r', '\n');

            //var input = new StringReader(yaml);

            
            //var deserializer = new DeserializerBuilder()
            //    .IgnoreUnmatchedProperties()
            //     .WithNamingConvention(new CamelCaseNamingConvention())
            //     .Build();

            WeblogPostMetadata yamlMeta = null;
            try
            {
                yamlMeta = ParseFromYaml(yaml);  //deserializer.Deserialize<WeblogPostMetadata>(input);
            }
            catch
            {
                return meta;
            }

            if (yamlMeta == null)
                return meta;

	        if (meta.CustomFields == null)
		        meta.CustomFields = new Dictionary<string, CustomField>();
            
            meta = yamlMeta;

            meta.MarkdownBody = markdown.Replace(extractedYaml,"");
            meta.RawMarkdownBody = markdown;
            meta.YamlFrontMatter = yaml;
            if (string.IsNullOrEmpty(meta.WeblogName))
                meta.WeblogName = WeblogAddinConfiguration.Current.LastWeblogAccessed;


            if (post != null)
            {
                post.Title = meta.Title?.Trim();
                if (!string.IsNullOrEmpty(meta.Categories))
                {
                    post.Categories = meta.Categories.Split(new[] {','}, StringSplitOptions.RemoveEmptyEntries);
                    for (int i = 0; i < post.Categories.Length; i++)
                        post.Categories[i] = post.Categories[i].Trim();
                }

                if (!string.IsNullOrEmpty(meta.Keywords))
                {
                    post.Tags = meta.Keywords.Split(new[] {','}, StringSplitOptions.RemoveEmptyEntries);
                    for (int i = 0; i < post.Tags.Length; i++)
                        post.Tags[i] = post.Tags[i].Trim();
                }

                post.Permalink = meta.Permalink;
                post.DateCreated = meta.PostDate;
                if (post.DateCreated < new DateTime(2000, 1, 1))
                    post.DateCreated = DateTime.Now;

                post.mt_excerpt = meta.Abstract;
                post.mt_keywords = meta.Keywords;

                if (meta.CustomFields != null)
                    post.CustomFields = meta.CustomFields.Values.ToArray();
            }

            return meta;
        }


        /// <summary>
        /// Parses a YAML block of text into a WeblogPostMetaData structure.
        /// Any fields that don't match the meta structure are parsed into
        /// ExtraFields
        /// </summary>
        /// <param name="yaml"></param>
        /// <returns></returns>
        public static WeblogPostMetadata ParseFromYaml(string yaml)
        {
            var parser = new YamlStream();
            try
            {
                parser.Load(new StringReader(yaml));
            }
            catch
            {
                return null;
            }

            var meta = new WeblogPostMetadata();

            var root = (YamlMappingNode) parser.Documents[0].RootNode;
            foreach (var entry in root.Children)
            {
                var key = entry.Key?.ToString();

                if(string.IsNullOrEmpty(key))
                    continue;
                if (key.Equals("Title", StringComparison.OrdinalIgnoreCase))
                {
                    meta.Title = entry.Value?.ToString();
                }
                else if (key.Equals("Abstract", StringComparison.OrdinalIgnoreCase))
                {
                    meta.Abstract = entry.Value?.ToString();
                }
                else if (key.Equals("PostId", StringComparison.OrdinalIgnoreCase))
                {
                    meta.PostId = entry.Value?.ToString();
                }
                else if (key.Equals("PostStatus", StringComparison.OrdinalIgnoreCase))
                {
                    meta.PostStatus = entry.Value?.ToString();
                }
                
                else if (key.Equals("PostDate", StringComparison.OrdinalIgnoreCase))
                {
                    if (!DateTime.TryParse(entry.Value.ToString(), out DateTime dt))
                        meta.PostDate = DateTime.UtcNow;
                    else
                        meta.PostDate = dt;
                }
                else if (key.Equals("WeblogName", StringComparison.OrdinalIgnoreCase))
                {
                    meta.WeblogName = entry.Value?.ToString();
                }
                else if (key.Equals("Keywords", StringComparison.OrdinalIgnoreCase))
                {
                    meta.Keywords = entry.Value?.ToString();
                }
                else if (key.Equals("Categories", StringComparison.OrdinalIgnoreCase))
                {
                    meta.Categories = entry.Value?.ToString();
                }
                else if (key.Equals("PermaLink", StringComparison.OrdinalIgnoreCase))
                {
                    meta.Permalink = entry.Value?.ToString();
                }
                else if (key.Equals("FeaturedImageUrl", StringComparison.OrdinalIgnoreCase))
                {
                    meta.FeaturedImageUrl = entry.Value?.ToString();
                }
                else if (key.Equals("FeaturedImageId", StringComparison.OrdinalIgnoreCase))
                {
                    meta.FeaturedImageId = entry.Value?.ToString();
                }
                else if (key.Equals("DontInferFeaturedImage", StringComparison.OrdinalIgnoreCase))
                {
                    bool.TryParse(entry.Value.ToString(), out bool val);
                    meta.DontInferFeaturedImage =val;
                }
                else if (key.Equals("DontStripH1Header", StringComparison.OrdinalIgnoreCase))
                {
                    bool.TryParse(entry.Value.ToString(), out bool val);
                    meta.DontStripH1Header = val;
                }
                else if (key.Equals("CustomFields", StringComparison.OrdinalIgnoreCase))
                {
                    var fields = (YamlMappingNode) entry.Value;
                    foreach (var item in fields.Children)
                    {
                        string k = item.Key.ToString();
                        string v = ((YamlMappingNode) item.Value).Children["value"].ToString();
                        meta.CustomFields.Add(k, new CustomField {Value = v, Key = k});
                    }
                }
                else
                {
                    meta.ExtraValues.Add(entry.Key.ToString(), entry.Value?.ToString());
                }

            }

            return meta;
            
        }

        /// <summary>
        /// Serializes a meta weblog post to YAML including extra fields.
        /// </summary>
        /// <param name="meta">MetaWebLogPostData instance or null which uses this object</param>
        /// <param name="addFrontMatterDashes">if true adds the leading and trailing Frontmatter dashes to the YAML</param>
        /// <returns></returns>
        public string SerializeToYaml(WeblogPostMetadata meta = null, bool addFrontMatterDashes = false)
        {
            if (meta == null)
                meta = this;

            var serializer = new SerializerBuilder()
                .WithNamingConvention(CamelCaseNamingConvention.Instance)
                .Build();

            // hide fields  if none are set
            var customFields = CustomFields;
            if (CustomFields != null && CustomFields.Count < 1)
                CustomFields = null;
            if (string.IsNullOrEmpty(PostId))
                PostId = null;

            string yaml =  serializer.Serialize(this);

            if (meta.ExtraValues.Count > 0)
            {
                yaml = yaml.TrimEnd() + mmApp.NewLine +  ExtraValuesToYaml(ExtraValues);
            }

            if (addFrontMatterDashes)
            {
                yaml = $"---{mmApp.NewLine}{yaml}---{mmApp.NewLine}";
            }

            return yaml;
        }


        /// <summary>
        /// Serializes any extra values that are in the ExtraValues collection
        /// and creates YAML from them that can be appended to the serialized
        /// Yaml data of the schema bound fields.
        /// </summary>
        /// <param name="extraValues"></param>
        /// <returns></returns>
        public string ExtraValuesToYaml(IDictionary<string, object> extraValues)
        {
            // serialize extra fields that aren't part of the scheme explicitly
            var root = new YamlMappingNode();
            var doc = new YamlDocument(root);

            foreach (var extra in extraValues)
            {
                root.Add(extra.Key.ToString(), extra.Value?.ToString().Trim());
            }

            var yamlStream = new YamlStream(doc);
            var buffer = new StringBuilder();
            string yamlText;
            using (var writer = new StringWriter(buffer))
            {
                yamlStream.Save(writer);
                yamlText = writer.ToString();
            }
            return yamlText.TrimEnd('\r','\n','.') + mmApp.NewLine;
        }

        /// <summary>
        /// Parses the current Raw post data and updates the meta data
        /// to reflect the latest state of the Meta object.
        /// Returns a string of the final Markdown and updates these properties:
        /// * MarkdownBody
        /// * YamlFrontMatter
        /// * RawMarkdownBody
        /// </summary>
        /// <param name="rawMarkdown">the raw Markdown that contains both Markdown and YAML. If not passed uses RawMarkdownBody which is the full document.</param>
        /// <returns>YAML or null. Also sets MarkdownBody, YamlFrontMatter and RawMarkdownBody properties.</returns>
        public string SetPostYamlFromMetaData(string rawMarkdownBody = null)
        {
            if (string.IsNullOrEmpty(rawMarkdownBody))
                rawMarkdownBody = RawMarkdownBody;
            if (string.IsNullOrEmpty(rawMarkdownBody))
                return null;

            string markdown = rawMarkdownBody.Trim();

            //var serializer = new SerializerBuilder()
            //     .WithNamingConvention(new CamelCaseNamingConvention())
            //     .Build();

            // hide fields  if none are set
            var customFields = CustomFields;
            if (CustomFields != null && CustomFields.Count < 1)
                CustomFields = null;
            if (string.IsNullOrEmpty(PostId))
                PostId = null;

            string yaml = SerializeToYaml(this);  //  serializer.Serialize(this);

            // reset customfields
            CustomFields = customFields;

            string extractedYaml = null;
            var match = MarkdownUtilities.YamlExtractionRegex.Match(markdown);
            if (match.Success)
                extractedYaml = match.Value;

            if (!string.IsNullOrEmpty(extractedYaml))
                markdown = markdown.Replace(extractedYaml, "");
            else
                markdown = markdown.Trim();

            MarkdownBody = markdown;
            YamlFrontMatter = $"---{mmApp.NewLine}{yaml}---{mmApp.NewLine}";
            RawMarkdownBody = YamlFrontMatter + MarkdownBody;

            // TODO: strip out old meta data
            string config = StringUtils.ExtractString(markdown,
                "<!-- Post Configuration -->",
                "<!-- End Post Configuration -->",
                caseSensitive: false, allowMissingEndDelimiter: true, returnDelimiters: true);

            if (!string.IsNullOrEmpty(config))
                RawMarkdownBody = RawMarkdownBody.Replace(config, "");

            return RawMarkdownBody;
        }

        /// <summary>
        /// Strips the Markdown Meta data from the message and populates
        /// the post structure with the meta data values.
        /// </summary>
        /// <param name="markdown"></param>
        /// <param name="post"></param>
        /// <param name="weblogInfo"></param>
        /// <returns></returns>
        public static WeblogPostMetadata GetPostConfigFromMarkdown(string markdown, Post post, WeblogInfo weblogInfo)
        {
            var meta = new WeblogPostMetadata()
            {
                RawMarkdownBody = markdown,
                MarkdownBody = markdown,
                WeblogName = WeblogAddinConfiguration.Current.LastWeblogAccessed,
                CustomFields = new Dictionary<string, CustomField>()
            };

            // check for title in first line and remove it
            // since the body shouldn't render the title
            var lines = StringUtils.GetLines(markdown, 40);
            if (lines.Length > 2 && lines[0] == "---")
            {
                var block = StringUtils.ExtractString(meta.MarkdownBody, "---", "\n---", returnDelimiters: true);
                if (!string.IsNullOrEmpty(block))
                {
                    meta = GetPostYamlConfigFromMarkdown(markdown, post);
                    meta.RawMarkdownBody = markdown;
                    if (string.IsNullOrEmpty(meta.WeblogName))
                        meta.WeblogName = WeblogAddinConfiguration.Current.LastWeblogAccessed;

                    meta.MarkdownBody = meta.MarkdownBody.Replace(block, "").Trim();

                    // update to what's left
                    lines = StringUtils.GetLines(meta.MarkdownBody, 10);
                }
            }
            if (lines.Length > 0 && lines[0].StartsWith("# "))
            {
                if (!meta.DontStripH1Header && weblogInfo.Type != WeblogTypes.Medium) // medium wants the header in the text
                    meta.MarkdownBody = meta.MarkdownBody.Replace(lines[0], "").Trim();

                if (string.IsNullOrEmpty(meta.Title))
                    meta.Title = lines[0].Trim().Substring(2);
            }

            string config = StringUtils.ExtractString(markdown,
                "<!-- Post Configuration -->",
                "<!-- End Post Configuration -->",
                caseSensitive: false, allowMissingEndDelimiter: true, returnDelimiters: true);

            if (string.IsNullOrEmpty(config))
                return meta;

            // strip the config section
            meta.MarkdownBody = meta.MarkdownBody.Replace(config, "");


            string title = StringUtils.ExtractString(config, "\n<title>", "</title>").Trim();
            if (string.IsNullOrEmpty(meta.Title))
                meta.Title = title;
            meta.Abstract = StringUtils.ExtractString(config, "\n<abstract>", "\n</abstract>").Trim();
            meta.Keywords = StringUtils.ExtractString(config, "\n<keywords>", "\n</keywords>").Trim();
            meta.Categories = StringUtils.ExtractString(config, "\n<categories>", "\n</categories>").Trim();
            meta.PostId = StringUtils.ExtractString(config, "\n<postid>", "</postid>").Trim();
            string strIsDraft = StringUtils.ExtractString(config, "\n<isDraft>", "</isDraft>").Trim();
            if (strIsDraft != null && strIsDraft == "True")
                meta.PostStatus = "draft";
            string weblogName = StringUtils.ExtractString(config, "\n<weblog>", "</weblog>").Trim();
            if (!string.IsNullOrEmpty(weblogName))
                meta.WeblogName = weblogName;

            string inferFeaturedImage = StringUtils.ExtractString(config, "\n<inferFeaturedImage>", "</inferFeaturedImage>");
            if (!string.IsNullOrEmpty(inferFeaturedImage))
                meta.DontInferFeaturedImage = inferFeaturedImage != "False" && inferFeaturedImage != "false";

            string featuredImageUrl = StringUtils.ExtractString(config, "\n<featuredImage>", "</featuredImage>");
            if (!string.IsNullOrEmpty(featuredImageUrl))
                meta.FeaturedImageUrl = featuredImageUrl.Trim();

            string featuredImageId = StringUtils.ExtractString(config, "\n<featuredImageId>", "</featuredImageId>");
            if (!string.IsNullOrEmpty(featuredImageId))
                meta.FeaturedImageId = featuredImageId.Trim();


            string customFieldsString = StringUtils.ExtractString(config, "\n<customFields>", "</customFields>", returnDelimiters: true);
            if (!string.IsNullOrEmpty(customFieldsString))
            {

                try
                {
                    var dom = new XmlDocument();
                    dom.LoadXml(customFieldsString);

                    foreach (XmlNode child in dom.DocumentElement.ChildNodes)
                    {
                        if (child.NodeType == XmlNodeType.Element)
                        {
                            var key = child.FirstChild.InnerText;
                            var value = child.ChildNodes[1].InnerText;
                            string id = null;
                            if (child.ChildNodes.Count > 2)
                                id = child.ChildNodes[2].InnerText;

                            meta.CustomFields.Add(key, new CustomField { Key = key, Value = value, Id = id });
                        }
                    }
                }
                catch { }
            }

            post.Title = meta.Title?.Trim();
            post.Categories = meta.Categories.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            post.Tags = meta.Keywords.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            post.mt_excerpt = meta.Abstract;
            post.mt_keywords = meta.Keywords;

            return meta;
        }


		#region INotify Property Changed

		public event PropertyChangedEventHandler PropertyChanged;


        public virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        #endregion
    }
}
